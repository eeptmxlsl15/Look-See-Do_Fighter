// <auto-generated>
// This code was auto-generated by a tool, every time
// the tool executes this code will be reset.
//
// If you need to extend the classes generated to add
// fields or methods to them, please create partial
// declarations in another file.
// </auto-generated>
#pragma warning disable 0109
#pragma warning disable 1591


namespace Quantum {
  using Photon.Deterministic;
  using Quantum;
  using Quantum.Core;
  using Quantum.Collections;
  using Quantum.Inspector;
  using Quantum.Physics2D;
  using Quantum.Physics3D;
  using Byte = System.Byte;
  using SByte = System.SByte;
  using Int16 = System.Int16;
  using UInt16 = System.UInt16;
  using Int32 = System.Int32;
  using UInt32 = System.UInt32;
  using Int64 = System.Int64;
  using UInt64 = System.UInt64;
  using Boolean = System.Boolean;
  using String = System.String;
  using Object = System.Object;
  using FlagsAttribute = System.FlagsAttribute;
  using SerializableAttribute = System.SerializableAttribute;
  using MethodImplAttribute = System.Runtime.CompilerServices.MethodImplAttribute;
  using MethodImplOptions = System.Runtime.CompilerServices.MethodImplOptions;
  using FieldOffsetAttribute = System.Runtime.InteropServices.FieldOffsetAttribute;
  using StructLayoutAttribute = System.Runtime.InteropServices.StructLayoutAttribute;
  using LayoutKind = System.Runtime.InteropServices.LayoutKind;
  #if QUANTUM_UNITY //;
  using TooltipAttribute = UnityEngine.TooltipAttribute;
  using HeaderAttribute = UnityEngine.HeaderAttribute;
  using SpaceAttribute = UnityEngine.SpaceAttribute;
  using RangeAttribute = UnityEngine.RangeAttribute;
  using HideInInspectorAttribute = UnityEngine.HideInInspector;
  using PreserveAttribute = UnityEngine.Scripting.PreserveAttribute;
  using FormerlySerializedAsAttribute = UnityEngine.Serialization.FormerlySerializedAsAttribute;
  using MovedFromAttribute = UnityEngine.Scripting.APIUpdating.MovedFromAttribute;
  using CreateAssetMenu = UnityEngine.CreateAssetMenuAttribute;
  using RuntimeInitializeOnLoadMethodAttribute = UnityEngine.RuntimeInitializeOnLoadMethodAttribute;
  #endif //;
  
  [Flags()]
  public enum AnimatorStateType : byte {
    None,
    FromState,
    CurrentState,
    ToState,
  }
  public enum CountAttackType : int {
    Normal,
    Combo,
  }
  public enum DelayGuardType : int {
    Normal,
    Stun,
    Combo,
  }
  public enum DirectionType : int {
    None,
    Left,
    Right,
  }
  public enum HitboxAttackType : int {
    High,
    Mid,
    Low,
  }
  public enum HomingType : int {
    Stun,
    Combo,
    Homing,
  }
  public enum PlayerMoveState : byte {
    Idle,
    WalkForward,
    WalkBackward,
    DashForward,
    DashBackward,
    Crouch,
  }
  [System.FlagsAttribute()]
  public enum InputButtons : int {
    Left = 1 << 0,
    Right = 1 << 1,
    Up = 1 << 2,
    Down = 1 << 3,
    LeftPunch = 1 << 4,
    RightPunch = 1 << 5,
    LeftKick = 1 << 6,
    RightKick = 1 << 7,
  }
  public static unsafe partial class FlagsExtensions {
    public static Boolean IsFlagSet(this InputButtons self, InputButtons flag) {
      return (self & flag) == flag;
    }
    public static InputButtons SetFlag(this InputButtons self, InputButtons flag) {
      return self | flag;
    }
    public static InputButtons ClearFlag(this InputButtons self, InputButtons flag) {
      return self & ~flag;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet128 {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[2];
    public const Int32 BitsSize = 128;
    public Int32 Length {
      get {
        return 128;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet128*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 128, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet128 FromArray(UInt64[] values) {
      Assert.Always(2 == values.Length, "Invalid array size", values.Length);
      BitSet128 result = default;
      for (int i = 0; i < 2; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 128);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 16);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 4463;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 2);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet128*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 2);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet2048 {
    public const Int32 SIZE = 256;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[32];
    public const Int32 BitsSize = 2048;
    public Int32 Length {
      get {
        return 2048;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet2048*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 2048, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet2048 FromArray(UInt64[] values) {
      Assert.Always(32 == values.Length, "Invalid array size", values.Length);
      BitSet2048 result = default;
      for (int i = 0; i < 32; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 2048);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 256);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 32; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 32; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3319;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 32);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet2048*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 32);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet256 {
    public const Int32 SIZE = 32;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[4];
    public const Int32 BitsSize = 256;
    public Int32 Length {
      get {
        return 256;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet256*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 256, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet256 FromArray(UInt64[] values) {
      Assert.Always(4 == values.Length, "Invalid array size", values.Length);
      BitSet256 result = default;
      for (int i = 0; i < 4; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 256);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 32);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0]);
        result += Maths.CountSetBits(p[1]);
        result += Maths.CountSetBits(p[2]);
        result += Maths.CountSetBits(p[3]);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if (p[0] != 0) return true;
        if (p[1] != 0) return true;
        if (p[2] != 0) return true;
        if (p[3] != 0) return true;
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14057;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 4);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet256*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 4);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet4096 {
    public const Int32 SIZE = 512;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[64];
    public const Int32 BitsSize = 4096;
    public Int32 Length {
      get {
        return 4096;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet4096*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 4096, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet4096 FromArray(UInt64[] values) {
      Assert.Always(64 == values.Length, "Invalid array size", values.Length);
      BitSet4096 result = default;
      for (int i = 0; i < 64; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 4096);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 512);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 64; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 64; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1433;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 64);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet4096*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 64);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet512 {
    public const Int32 SIZE = 64;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[8];
    public const Int32 BitsSize = 512;
    public Int32 Length {
      get {
        return 512;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet512*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 512, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet512 FromArray(UInt64[] values) {
      Assert.Always(8 == values.Length, "Invalid array size", values.Length);
      BitSet512 result = default;
      for (int i = 0; i < 8; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 512);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 64);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        for (int i = 0; i < 8; ++i) {
          result += Maths.CountSetBits(p[i]);
        }
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        for (int i = 0; i < 8; ++i) {
          if (p[i] != 0) return true;
        }
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 17491;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 8);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet512*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 8);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BitSet6 {
    public const Int32 SIZE = 8;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    public fixed UInt64 Bits[1];
    public const Int32 BitsSize = 6;
    public Int32 Length {
      get {
        return 6;
      }
    }
    public static void Print(void* ptr, FramePrinter printer) {
      var p = (BitSet6*)ptr;
      printer.ScopeBegin();
      UnmanagedUtils.PrintBytesBits((byte*)&p->Bits, 6, 64, printer);
      printer.ScopeEnd();
    }
    public static BitSet6 FromArray(UInt64[] values) {
      Assert.Always(1 == values.Length, "Invalid array size", values.Length);
      BitSet6 result = default;
      for (int i = 0; i < 1; ++i) {
        result.Bits[i] = values[i];
      }
      return result;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Set(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) |= (1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void Clear(Int32 bit) {
      Assert.Check(bit >= 0 && bit < 6);
      fixed (UInt64* p = Bits) (p[bit/64]) &= ~(1UL<<(bit%64));
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public void ClearAll() {
      fixed (UInt64* p = Bits) Native.Utils.Clear(p, 8);
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsSet(Int32 bit) {
      fixed (UInt64* p = Bits) return ((p[bit/64])&(1UL<<(bit%64))) != 0UL;
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Int32 GetSetCount() {
      fixed (UInt64* p = Bits) {
        int result = 0;
        result += Maths.CountSetBits(p[0] & 0x3FUL);
        return result;
      }
    }
    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    public Boolean IsAnySet() {
      fixed (UInt64* p = Bits) {
        if ((p[0] & 0x3FUL) != 0) return true;
        return false;
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 13669;
        fixed (UInt64* p = Bits) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 1);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BitSet6*)ptr;
        serializer.Stream.SerializeBuffer(&p->Bits[0], 1);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct BlendTreeWeights {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public QListPtr<FP> Values;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 14387;
        hash = hash * 31 + Values.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Values = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (BlendTreeWeights*)ptr;
        QList.Serialize(&p->Values, serializer, Statics.SerializeFP);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct Input {
    public const Int32 SIZE = 96;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(12)]
    public Button Left;
    [FieldOffset(48)]
    public Button Right;
    [FieldOffset(84)]
    public Button Up;
    [FieldOffset(0)]
    public Button Down;
    [FieldOffset(36)]
    public Button LeftPunch;
    [FieldOffset(72)]
    public Button RightPunch;
    [FieldOffset(24)]
    public Button LeftKick;
    [FieldOffset(60)]
    public Button RightKick;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19249;
        hash = hash * 31 + Left.GetHashCode();
        hash = hash * 31 + Right.GetHashCode();
        hash = hash * 31 + Up.GetHashCode();
        hash = hash * 31 + Down.GetHashCode();
        hash = hash * 31 + LeftPunch.GetHashCode();
        hash = hash * 31 + RightPunch.GetHashCode();
        hash = hash * 31 + LeftKick.GetHashCode();
        hash = hash * 31 + RightKick.GetHashCode();
        return hash;
      }
    }
    static partial void GetMaxCountCodeGen(ref int maxCount) {
      maxCount = 6;
    }
    public Boolean IsDown(InputButtons button) {
      switch (button) {
        case InputButtons.Left: return Left.IsDown;
        case InputButtons.Right: return Right.IsDown;
        case InputButtons.Up: return Up.IsDown;
        case InputButtons.Down: return Down.IsDown;
        case InputButtons.LeftPunch: return LeftPunch.IsDown;
        case InputButtons.RightPunch: return RightPunch.IsDown;
        case InputButtons.LeftKick: return LeftKick.IsDown;
        case InputButtons.RightKick: return RightKick.IsDown;
        default: return false;
      }
    }
    public Boolean WasPressed(InputButtons button) {
      switch (button) {
        case InputButtons.Left: return Left.WasPressed;
        case InputButtons.Right: return Right.WasPressed;
        case InputButtons.Up: return Up.WasPressed;
        case InputButtons.Down: return Down.WasPressed;
        case InputButtons.LeftPunch: return LeftPunch.WasPressed;
        case InputButtons.RightPunch: return RightPunch.WasPressed;
        case InputButtons.LeftKick: return LeftKick.WasPressed;
        case InputButtons.RightKick: return RightKick.WasPressed;
        default: return false;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (Input*)ptr;
        Button.Serialize(&p->Down, serializer);
        Button.Serialize(&p->Left, serializer);
        Button.Serialize(&p->LeftKick, serializer);
        Button.Serialize(&p->LeftPunch, serializer);
        Button.Serialize(&p->Right, serializer);
        Button.Serialize(&p->RightKick, serializer);
        Button.Serialize(&p->RightPunch, serializer);
        Button.Serialize(&p->Up, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LayerData {
    public const Int32 SIZE = 152;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(96)]
    [HideInInspector()]
    public FP Time;
    [FieldOffset(80)]
    [HideInInspector()]
    public FP NormalizedTime;
    [FieldOffset(64)]
    [HideInInspector()]
    public FP LastTime;
    [FieldOffset(72)]
    [HideInInspector()]
    public FP Length;
    [FieldOffset(4)]
    [HideInInspector()]
    public Int32 CurrentStateId;
    [FieldOffset(20)]
    [HideInInspector()]
    public QBoolean Freeze;
    [FieldOffset(88)]
    [HideInInspector()]
    public FP Speed;
    [FieldOffset(8)]
    [HideInInspector()]
    public Int32 FromStateId;
    [FieldOffset(56)]
    [HideInInspector()]
    public FP FromStateTime;
    [FieldOffset(40)]
    [HideInInspector()]
    public FP FromStateLastTime;
    [FieldOffset(48)]
    [HideInInspector()]
    public FP FromStateNormalizedTime;
    [FieldOffset(32)]
    [HideInInspector()]
    public FP FromLength;
    [FieldOffset(12)]
    [HideInInspector()]
    public Int32 ToStateId;
    [FieldOffset(128)]
    [HideInInspector()]
    public FP ToStateTime;
    [FieldOffset(112)]
    [HideInInspector()]
    public FP ToStateLastTime;
    [FieldOffset(120)]
    [HideInInspector()]
    public FP ToStateNormalizedTime;
    [FieldOffset(104)]
    [HideInInspector()]
    public FP ToLength;
    [FieldOffset(16)]
    [HideInInspector()]
    public Int32 TransitionIndex;
    [FieldOffset(144)]
    [HideInInspector()]
    public FP TransitionTime;
    [FieldOffset(136)]
    [HideInInspector()]
    public FP TransitionDuration;
    [FieldOffset(0)]
    [HideInInspector()]
    public Int32 AnimatorBlendCount;
    [FieldOffset(24)]
    public QBoolean IgnoreTransitions;
    [FieldOffset(28)]
    [HideInInspector()]
    public QDictionaryPtr<Int32, BlendTreeWeights> BlendTreeWeights;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16301;
        hash = hash * 31 + Time.GetHashCode();
        hash = hash * 31 + NormalizedTime.GetHashCode();
        hash = hash * 31 + LastTime.GetHashCode();
        hash = hash * 31 + Length.GetHashCode();
        hash = hash * 31 + CurrentStateId.GetHashCode();
        hash = hash * 31 + Freeze.GetHashCode();
        hash = hash * 31 + Speed.GetHashCode();
        hash = hash * 31 + FromStateId.GetHashCode();
        hash = hash * 31 + FromStateTime.GetHashCode();
        hash = hash * 31 + FromStateLastTime.GetHashCode();
        hash = hash * 31 + FromStateNormalizedTime.GetHashCode();
        hash = hash * 31 + FromLength.GetHashCode();
        hash = hash * 31 + ToStateId.GetHashCode();
        hash = hash * 31 + ToStateTime.GetHashCode();
        hash = hash * 31 + ToStateLastTime.GetHashCode();
        hash = hash * 31 + ToStateNormalizedTime.GetHashCode();
        hash = hash * 31 + ToLength.GetHashCode();
        hash = hash * 31 + TransitionIndex.GetHashCode();
        hash = hash * 31 + TransitionTime.GetHashCode();
        hash = hash * 31 + TransitionDuration.GetHashCode();
        hash = hash * 31 + AnimatorBlendCount.GetHashCode();
        hash = hash * 31 + IgnoreTransitions.GetHashCode();
        hash = hash * 31 + BlendTreeWeights.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      BlendTreeWeights = default;
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LayerData*)ptr;
        serializer.Stream.Serialize(&p->AnimatorBlendCount);
        serializer.Stream.Serialize(&p->CurrentStateId);
        serializer.Stream.Serialize(&p->FromStateId);
        serializer.Stream.Serialize(&p->ToStateId);
        serializer.Stream.Serialize(&p->TransitionIndex);
        QBoolean.Serialize(&p->Freeze, serializer);
        QBoolean.Serialize(&p->IgnoreTransitions, serializer);
        QDictionary.Serialize(&p->BlendTreeWeights, serializer, Statics.SerializeInt32, Statics.SerializeBlendTreeWeights);
        FP.Serialize(&p->FromLength, serializer);
        FP.Serialize(&p->FromStateLastTime, serializer);
        FP.Serialize(&p->FromStateNormalizedTime, serializer);
        FP.Serialize(&p->FromStateTime, serializer);
        FP.Serialize(&p->LastTime, serializer);
        FP.Serialize(&p->Length, serializer);
        FP.Serialize(&p->NormalizedTime, serializer);
        FP.Serialize(&p->Speed, serializer);
        FP.Serialize(&p->Time, serializer);
        FP.Serialize(&p->ToLength, serializer);
        FP.Serialize(&p->ToStateLastTime, serializer);
        FP.Serialize(&p->ToStateNormalizedTime, serializer);
        FP.Serialize(&p->ToStateTime, serializer);
        FP.Serialize(&p->TransitionDuration, serializer);
        FP.Serialize(&p->TransitionTime, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct _globals_ {
    public const Int32 SIZE = 1200;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(1196)]
    private fixed Byte _alignment_padding_[4];
    [FieldOffset(0)]
    public AssetRef<Map> Map;
    [FieldOffset(8)]
    public FP DeltaTime;
    [FieldOffset(16)]
    public NavMeshRegionMask NavMeshRegions;
    [FieldOffset(80)]
    public PhysicsEngineState PhysicsState2D;
    [FieldOffset(96)]
    public PhysicsEngineState PhysicsState3D;
    [FieldOffset(112)]
    public RNGSession RngSession;
    [FieldOffset(128)]
    public FrameMetaData FrameMetaData;
    [FieldOffset(176)]
    public BitSet1024 Systems;
    [FieldOffset(304)]
    public PhysicsSceneSettings PhysicsSettings;
    [FieldOffset(600)]
    public Int32 PlayerConnectedCount;
    [FieldOffset(604)]
    [FramePrinter.FixedArrayAttribute(typeof(Input), 6)]
    private fixed Byte _input_[576];
    [FieldOffset(1184)]
    public BitSet6 PlayerLastConnectionState;
    [FieldOffset(1192)]
    public Int32 AsteroidsWaveCount;
    public FixedArray<Input> input {
      get {
        fixed (byte* p = _input_) { return new FixedArray<Input>(p, 96, 6); }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 12473;
        hash = hash * 31 + Map.GetHashCode();
        hash = hash * 31 + DeltaTime.GetHashCode();
        hash = hash * 31 + NavMeshRegions.GetHashCode();
        hash = hash * 31 + PhysicsState2D.GetHashCode();
        hash = hash * 31 + PhysicsState3D.GetHashCode();
        hash = hash * 31 + RngSession.GetHashCode();
        hash = hash * 31 + FrameMetaData.GetHashCode();
        hash = hash * 31 + Systems.GetHashCode();
        hash = hash * 31 + PhysicsSettings.GetHashCode();
        hash = hash * 31 + PlayerConnectedCount.GetHashCode();
        hash = hash * 31 + HashCodeUtils.GetArrayHashCode(input);
        hash = hash * 31 + PlayerLastConnectionState.GetHashCode();
        hash = hash * 31 + AsteroidsWaveCount.GetHashCode();
        return hash;
      }
    }
    static partial void SerializeCodeGen(void* ptr, FrameSerializer serializer) {
        var p = (_globals_*)ptr;
        AssetRef.Serialize(&p->Map, serializer);
        FP.Serialize(&p->DeltaTime, serializer);
        NavMeshRegionMask.Serialize(&p->NavMeshRegions, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState2D, serializer);
        PhysicsEngineState.Serialize(&p->PhysicsState3D, serializer);
        RNGSession.Serialize(&p->RngSession, serializer);
        FrameMetaData.Serialize(&p->FrameMetaData, serializer);
        Quantum.BitSet1024.Serialize(&p->Systems, serializer);
        PhysicsSceneSettings.Serialize(&p->PhysicsSettings, serializer);
        serializer.Stream.Serialize(&p->PlayerConnectedCount);
        FixedArray.Serialize(p->input, serializer, Statics.SerializeInput);
        Quantum.BitSet6.Serialize(&p->PlayerLastConnectionState, serializer);
        serializer.Stream.Serialize(&p->AsteroidsWaveCount);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  [Union()]
  public unsafe partial struct AnimatorRuntimeVariable {
    public const Int32 SIZE = 16;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(0)]
    private Int32 _field_used_;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AnimatorRuntimeVariable.FPVALUE)]
    private FP _FPValue;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AnimatorRuntimeVariable.INTEGERVALUE)]
    private Int32 _IntegerValue;
    [FieldOffset(8)]
    [FieldOverlap(8)]
    [FramePrinter.PrintIf("_field_used_", Quantum.AnimatorRuntimeVariable.BOOLEANVALUE)]
    private QBoolean _BooleanValue;
    public const Int32 FPVALUE = 1;
    public const Int32 INTEGERVALUE = 2;
    public const Int32 BOOLEANVALUE = 3;
    public Int32 Field {
      get {
        return _field_used_;
      }
    }
    public FP* FPValue {
      get {
        fixed (FP* p = &_FPValue) {
          if (_field_used_ != FPVALUE) {
            Native.Utils.Clear(p, 8);
            _field_used_ = FPVALUE;
          }
          return p;
        }
      }
    }
    public Int32* IntegerValue {
      get {
        fixed (Int32* p = &_IntegerValue) {
          if (_field_used_ != INTEGERVALUE) {
            Native.Utils.Clear(p, 4);
            _field_used_ = INTEGERVALUE;
          }
          return p;
        }
      }
    }
    public QBoolean* BooleanValue {
      get {
        fixed (QBoolean* p = &_BooleanValue) {
          if (_field_used_ != BOOLEANVALUE) {
            Native.Utils.Clear(p, 4);
            _field_used_ = BOOLEANVALUE;
          }
          return p;
        }
      }
    }
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 19843;
        hash = hash * 31 + _field_used_.GetHashCode();
        hash = hash * 31 + _FPValue.GetHashCode();
        hash = hash * 31 + _IntegerValue.GetHashCode();
        hash = hash * 31 + _BooleanValue.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AnimatorRuntimeVariable*)ptr;
        if (serializer.InputMode) {
          serializer.Stream.SerializeBuffer((byte*)p, Quantum.AnimatorRuntimeVariable.SIZE);
          return;
        }
        serializer.Stream.Serialize(&p->_field_used_);
        if (p->_field_used_ == BOOLEANVALUE) {
          QBoolean.Serialize(&p->_BooleanValue, serializer);
        }
        if (p->_field_used_ == FPVALUE) {
          FP.Serialize(&p->_FPValue, serializer);
        }
        if (p->_field_used_ == INTEGERVALUE) {
          serializer.Stream.Serialize(&p->_IntegerValue);
        }
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct AnimatorComponent : Quantum.IComponent {
    public const Int32 SIZE = 24;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(16)]
    [HideInInspector()]
    public EntityRef Self;
    [FieldOffset(8)]
    public AssetRef<AnimatorGraph> AnimatorGraph;
    [FieldOffset(4)]
    [HideInInspector()]
    public QListPtr<LayerData> Layers;
    [FieldOffset(0)]
    [HideInInspector()]
    public QListPtr<AnimatorRuntimeVariable> AnimatorVariables;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 18413;
        hash = hash * 31 + Self.GetHashCode();
        hash = hash * 31 + AnimatorGraph.GetHashCode();
        hash = hash * 31 + Layers.GetHashCode();
        hash = hash * 31 + AnimatorVariables.GetHashCode();
        return hash;
      }
    }
    public void ClearPointers(FrameBase f, EntityRef entity) {
      Layers = default;
      AnimatorVariables = default;
    }
    public static void OnRemoved(FrameBase frame, EntityRef entity, void* ptr) {
      var p = (Quantum.AnimatorComponent*)ptr;
      p->ClearPointers((Frame)frame, entity);
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (AnimatorComponent*)ptr;
        QList.Serialize(&p->AnimatorVariables, serializer, Statics.SerializeAnimatorRuntimeVariable);
        QList.Serialize(&p->Layers, serializer, Statics.SerializeLayerData);
        AssetRef.Serialize(&p->AnimatorGraph, serializer);
        EntityRef.Serialize(&p->Self, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct DashInputBuffer : Quantum.IComponent {
    public const Int32 SIZE = 20;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public DirectionType LastDirection;
    [FieldOffset(4)]
    public DirectionType PrevDirection;
    [FieldOffset(12)]
    public Int32 LastInputTick;
    [FieldOffset(8)]
    public Int32 DashInputWindow;
    [FieldOffset(16)]
    public QBoolean LastInputPressed;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 8747;
        hash = hash * 31 + (Int32)LastDirection;
        hash = hash * 31 + (Int32)PrevDirection;
        hash = hash * 31 + LastInputTick.GetHashCode();
        hash = hash * 31 + DashInputWindow.GetHashCode();
        hash = hash * 31 + LastInputPressed.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (DashInputBuffer*)ptr;
        serializer.Stream.Serialize((Int32*)&p->LastDirection);
        serializer.Stream.Serialize((Int32*)&p->PrevDirection);
        serializer.Stream.Serialize(&p->DashInputWindow);
        serializer.Stream.Serialize(&p->LastInputTick);
        QBoolean.Serialize(&p->LastInputPressed, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LSDF_CameraInfo : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 cameraNum;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 10709;
        hash = hash * 31 + cameraNum.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LSDF_CameraInfo*)ptr;
        serializer.Stream.Serialize(&p->cameraNum);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LSDF_Ground : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 11311;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LSDF_Ground*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LSDF_HitboxInfo : Quantum.IComponent {
    public const Int32 SIZE = 72;
    public const Int32 ALIGNMENT = 8;
    [FieldOffset(64)]
    public EntityRef AttackerEntity;
    [FieldOffset(8)]
    public HitboxAttackType AttackType;
    [FieldOffset(0)]
    public CountAttackType CountType;
    [FieldOffset(4)]
    public DelayGuardType DelayGuardTpye;
    [FieldOffset(12)]
    public HomingType HomingReturnType;
    [FieldOffset(36)]
    public Int32 startFrame;
    [FieldOffset(16)]
    public Int32 attackDamage;
    [FieldOffset(24)]
    public Int32 enemyGuardTime;
    [FieldOffset(28)]
    public Int32 enemyHitTime;
    [FieldOffset(20)]
    public Int32 enemyCountTime;
    [FieldOffset(32)]
    public Int32 forceBack;
    [FieldOffset(48)]
    public QBoolean launcher;
    [FieldOffset(40)]
    public QBoolean dodgeHigh;
    [FieldOffset(44)]
    public QBoolean jumpAttack;
    [FieldOffset(52)]
    public QBoolean notSitLauncher;
    [FieldOffset(56)]
    public QBoolean wallLauncher;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 3677;
        hash = hash * 31 + AttackerEntity.GetHashCode();
        hash = hash * 31 + (Int32)AttackType;
        hash = hash * 31 + (Int32)CountType;
        hash = hash * 31 + (Int32)DelayGuardTpye;
        hash = hash * 31 + (Int32)HomingReturnType;
        hash = hash * 31 + startFrame.GetHashCode();
        hash = hash * 31 + attackDamage.GetHashCode();
        hash = hash * 31 + enemyGuardTime.GetHashCode();
        hash = hash * 31 + enemyHitTime.GetHashCode();
        hash = hash * 31 + enemyCountTime.GetHashCode();
        hash = hash * 31 + forceBack.GetHashCode();
        hash = hash * 31 + launcher.GetHashCode();
        hash = hash * 31 + dodgeHigh.GetHashCode();
        hash = hash * 31 + jumpAttack.GetHashCode();
        hash = hash * 31 + notSitLauncher.GetHashCode();
        hash = hash * 31 + wallLauncher.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LSDF_HitboxInfo*)ptr;
        serializer.Stream.Serialize((Int32*)&p->CountType);
        serializer.Stream.Serialize((Int32*)&p->DelayGuardTpye);
        serializer.Stream.Serialize((Int32*)&p->AttackType);
        serializer.Stream.Serialize((Int32*)&p->HomingReturnType);
        serializer.Stream.Serialize(&p->attackDamage);
        serializer.Stream.Serialize(&p->enemyCountTime);
        serializer.Stream.Serialize(&p->enemyGuardTime);
        serializer.Stream.Serialize(&p->enemyHitTime);
        serializer.Stream.Serialize(&p->forceBack);
        serializer.Stream.Serialize(&p->startFrame);
        QBoolean.Serialize(&p->dodgeHigh, serializer);
        QBoolean.Serialize(&p->jumpAttack, serializer);
        QBoolean.Serialize(&p->launcher, serializer);
        QBoolean.Serialize(&p->notSitLauncher, serializer);
        QBoolean.Serialize(&p->wallLauncher, serializer);
        EntityRef.Serialize(&p->AttackerEntity, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LSDF_Player : Quantum.IComponent {
    public const Int32 SIZE = 200;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(152)]
    public QBoolean isDashBack;
    [FieldOffset(156)]
    public QBoolean isDashFront;
    [FieldOffset(184)]
    public QBoolean isSit;
    [FieldOffset(188)]
    public QBoolean isStandUpGuard;
    [FieldOffset(140)]
    public QBoolean isAttack;
    [FieldOffset(168)]
    public QBoolean isHit;
    [FieldOffset(164)]
    public QBoolean isGuard;
    [FieldOffset(192)]
    public QBoolean isStun;
    [FieldOffset(148)]
    public QBoolean isCombo;
    [FieldOffset(180)]
    public QBoolean isParring;
    [FieldOffset(128)]
    public QBoolean canCounter;
    [FieldOffset(172)]
    public QBoolean isJump;
    [FieldOffset(136)]
    public QBoolean isAir;
    [FieldOffset(160)]
    public QBoolean isGround;
    [FieldOffset(176)]
    public QBoolean isOnWall;
    [FieldOffset(196)]
    public QBoolean isWallHit;
    [FieldOffset(132)]
    public QBoolean hitWallLauncher;
    [FieldOffset(144)]
    public QBoolean isCantMove;
    [FieldOffset(124)]
    public Int32 wallCount;
    [FieldOffset(116)]
    public Int32 hitCount;
    [FieldOffset(120)]
    public Int32 playerHp;
    [FieldOffset(112)]
    public Int32 DelayFrame;
    [FieldOffset(0)]
    public fixed Int32 CommandSkillMap[28];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 9949;
        hash = hash * 31 + isDashBack.GetHashCode();
        hash = hash * 31 + isDashFront.GetHashCode();
        hash = hash * 31 + isSit.GetHashCode();
        hash = hash * 31 + isStandUpGuard.GetHashCode();
        hash = hash * 31 + isAttack.GetHashCode();
        hash = hash * 31 + isHit.GetHashCode();
        hash = hash * 31 + isGuard.GetHashCode();
        hash = hash * 31 + isStun.GetHashCode();
        hash = hash * 31 + isCombo.GetHashCode();
        hash = hash * 31 + isParring.GetHashCode();
        hash = hash * 31 + canCounter.GetHashCode();
        hash = hash * 31 + isJump.GetHashCode();
        hash = hash * 31 + isAir.GetHashCode();
        hash = hash * 31 + isGround.GetHashCode();
        hash = hash * 31 + isOnWall.GetHashCode();
        hash = hash * 31 + isWallHit.GetHashCode();
        hash = hash * 31 + hitWallLauncher.GetHashCode();
        hash = hash * 31 + isCantMove.GetHashCode();
        hash = hash * 31 + wallCount.GetHashCode();
        hash = hash * 31 + hitCount.GetHashCode();
        hash = hash * 31 + playerHp.GetHashCode();
        hash = hash * 31 + DelayFrame.GetHashCode();
        fixed (Int32* p = CommandSkillMap) hash = hash * 31 + HashCodeUtils.GetArrayHashCode(p, 28);
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LSDF_Player*)ptr;
        serializer.Stream.SerializeBuffer(&p->CommandSkillMap[0], 28);
        serializer.Stream.Serialize(&p->DelayFrame);
        serializer.Stream.Serialize(&p->hitCount);
        serializer.Stream.Serialize(&p->playerHp);
        serializer.Stream.Serialize(&p->wallCount);
        QBoolean.Serialize(&p->canCounter, serializer);
        QBoolean.Serialize(&p->hitWallLauncher, serializer);
        QBoolean.Serialize(&p->isAir, serializer);
        QBoolean.Serialize(&p->isAttack, serializer);
        QBoolean.Serialize(&p->isCantMove, serializer);
        QBoolean.Serialize(&p->isCombo, serializer);
        QBoolean.Serialize(&p->isDashBack, serializer);
        QBoolean.Serialize(&p->isDashFront, serializer);
        QBoolean.Serialize(&p->isGround, serializer);
        QBoolean.Serialize(&p->isGuard, serializer);
        QBoolean.Serialize(&p->isHit, serializer);
        QBoolean.Serialize(&p->isJump, serializer);
        QBoolean.Serialize(&p->isOnWall, serializer);
        QBoolean.Serialize(&p->isParring, serializer);
        QBoolean.Serialize(&p->isSit, serializer);
        QBoolean.Serialize(&p->isStandUpGuard, serializer);
        QBoolean.Serialize(&p->isStun, serializer);
        QBoolean.Serialize(&p->isWallHit, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LSDF_TestEnemy : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 16979;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LSDF_TestEnemy*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct LSDF_Wall : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    private fixed Byte _alignment_padding_[4];
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 15901;
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (LSDF_Wall*)ptr;
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct PlayerLink : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public PlayerRef PlayerRef;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 21391;
        hash = hash * 31 + PlayerRef.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (PlayerLink*)ptr;
        PlayerRef.Serialize(&p->PlayerRef, serializer);
    }
  }
  [StructLayout(LayoutKind.Explicit)]
  public unsafe partial struct TickToDestroy : Quantum.IComponent {
    public const Int32 SIZE = 4;
    public const Int32 ALIGNMENT = 4;
    [FieldOffset(0)]
    public Int32 TickToDestroyAt;
    public override Int32 GetHashCode() {
      unchecked { 
        var hash = 1567;
        hash = hash * 31 + TickToDestroyAt.GetHashCode();
        return hash;
      }
    }
    public static void Serialize(void* ptr, FrameSerializer serializer) {
        var p = (TickToDestroy*)ptr;
        serializer.Stream.Serialize(&p->TickToDestroyAt);
    }
  }
  public unsafe partial interface ISignalOnAnimatorStateEnter : ISignal {
    void OnAnimatorStateEnter(Frame f, EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, Addons.Animator.AnimatorState state);
  }
  public unsafe partial interface ISignalOnAnimatorStateUpdate : ISignal {
    void OnAnimatorStateUpdate(Frame f, EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, Addons.Animator.AnimatorState state, FP time, AnimatorStateType stateType);
  }
  public unsafe partial interface ISignalOnAnimatorStateExit : ISignal {
    void OnAnimatorStateExit(Frame f, EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, Addons.Animator.AnimatorState state);
  }
  public unsafe partial interface ISignalOnTriggerNormalHit : ISignal {
    void OnTriggerNormalHit(Frame f, TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox);
  }
  public unsafe partial interface ISignalOnTriggerCounterHit : ISignal {
    void OnTriggerCounterHit(Frame f, TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox);
  }
  public unsafe partial interface ISignalOnTriggerGuard : ISignal {
    void OnTriggerGuard(Frame f, TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox);
  }
  public unsafe partial interface ISignalOnTriggerLauncherHit : ISignal {
    void OnTriggerLauncherHit(Frame f, TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox);
  }
  public unsafe partial interface ISignalOnTriggerWallHit : ISignal {
    void OnTriggerWallHit(Frame f, TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox);
  }
  public unsafe partial interface ISignalOnTriggerEnemyGuard : ISignal {
    void OnTriggerEnemyGuard(Frame f, TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox);
  }
  public unsafe partial interface ISignalOnTriggerEnemyParring : ISignal {
    void OnTriggerEnemyParring(Frame f, TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox);
  }
  public unsafe partial interface ISignalOnCollisionEnterWall : ISignal {
    void OnCollisionEnterWall(Frame f, CollisionInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Wall* wall);
  }
  public unsafe partial interface ISignalOnCollisionExitWall : ISignal {
    void OnCollisionExitWall(Frame f, ExitInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Wall* wall);
  }
  public unsafe partial interface ISignalOnCollisionWallHitEnter : ISignal {
    void OnCollisionWallHitEnter(Frame f, CollisionInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Wall* wall);
  }
  public unsafe partial interface ISignalOnCollisionGroundEnter : ISignal {
    void OnCollisionGroundEnter(Frame f, CollisionInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Ground* ground);
  }
  public unsafe partial interface ISignalOnCollisionGroundExit : ISignal {
    void OnCollisionGroundExit(Frame f, ExitInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Ground* ground);
  }
  public static unsafe partial class Constants {
  }
  public unsafe partial class Frame {
    private ISignalOnAnimatorStateEnter[] _ISignalOnAnimatorStateEnterSystems;
    private ISignalOnAnimatorStateUpdate[] _ISignalOnAnimatorStateUpdateSystems;
    private ISignalOnAnimatorStateExit[] _ISignalOnAnimatorStateExitSystems;
    private ISignalOnTriggerNormalHit[] _ISignalOnTriggerNormalHitSystems;
    private ISignalOnTriggerCounterHit[] _ISignalOnTriggerCounterHitSystems;
    private ISignalOnTriggerGuard[] _ISignalOnTriggerGuardSystems;
    private ISignalOnTriggerLauncherHit[] _ISignalOnTriggerLauncherHitSystems;
    private ISignalOnTriggerWallHit[] _ISignalOnTriggerWallHitSystems;
    private ISignalOnTriggerEnemyGuard[] _ISignalOnTriggerEnemyGuardSystems;
    private ISignalOnTriggerEnemyParring[] _ISignalOnTriggerEnemyParringSystems;
    private ISignalOnCollisionEnterWall[] _ISignalOnCollisionEnterWallSystems;
    private ISignalOnCollisionExitWall[] _ISignalOnCollisionExitWallSystems;
    private ISignalOnCollisionWallHitEnter[] _ISignalOnCollisionWallHitEnterSystems;
    private ISignalOnCollisionGroundEnter[] _ISignalOnCollisionGroundEnterSystems;
    private ISignalOnCollisionGroundExit[] _ISignalOnCollisionGroundExitSystems;
    partial void AllocGen() {
      _globals = (_globals_*)Context.Allocator.AllocAndClear(sizeof(_globals_));
    }
    partial void FreeGen() {
      Context.Allocator.Free(_globals);
    }
    partial void CopyFromGen(Frame frame) {
      Native.Utils.Copy(_globals, frame._globals, sizeof(_globals_));
    }
    partial void InitGen() {
      Initialize(this, this.SimulationConfig.Entities, 256);
      _ISignalOnAnimatorStateEnterSystems = BuildSignalsArray<ISignalOnAnimatorStateEnter>();
      _ISignalOnAnimatorStateUpdateSystems = BuildSignalsArray<ISignalOnAnimatorStateUpdate>();
      _ISignalOnAnimatorStateExitSystems = BuildSignalsArray<ISignalOnAnimatorStateExit>();
      _ISignalOnTriggerNormalHitSystems = BuildSignalsArray<ISignalOnTriggerNormalHit>();
      _ISignalOnTriggerCounterHitSystems = BuildSignalsArray<ISignalOnTriggerCounterHit>();
      _ISignalOnTriggerGuardSystems = BuildSignalsArray<ISignalOnTriggerGuard>();
      _ISignalOnTriggerLauncherHitSystems = BuildSignalsArray<ISignalOnTriggerLauncherHit>();
      _ISignalOnTriggerWallHitSystems = BuildSignalsArray<ISignalOnTriggerWallHit>();
      _ISignalOnTriggerEnemyGuardSystems = BuildSignalsArray<ISignalOnTriggerEnemyGuard>();
      _ISignalOnTriggerEnemyParringSystems = BuildSignalsArray<ISignalOnTriggerEnemyParring>();
      _ISignalOnCollisionEnterWallSystems = BuildSignalsArray<ISignalOnCollisionEnterWall>();
      _ISignalOnCollisionExitWallSystems = BuildSignalsArray<ISignalOnCollisionExitWall>();
      _ISignalOnCollisionWallHitEnterSystems = BuildSignalsArray<ISignalOnCollisionWallHitEnter>();
      _ISignalOnCollisionGroundEnterSystems = BuildSignalsArray<ISignalOnCollisionGroundEnter>();
      _ISignalOnCollisionGroundExitSystems = BuildSignalsArray<ISignalOnCollisionGroundExit>();
      _ComponentSignalsOnAdded = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      _ComponentSignalsOnRemoved = new ComponentReactiveCallbackInvoker[ComponentTypeId.Type.Length];
      BuildSignalsArrayOnComponentAdded<Quantum.AnimatorComponent>();
      BuildSignalsArrayOnComponentRemoved<Quantum.AnimatorComponent>();
      BuildSignalsArrayOnComponentAdded<CharacterController2D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController2D>();
      BuildSignalsArrayOnComponentAdded<CharacterController3D>();
      BuildSignalsArrayOnComponentRemoved<CharacterController3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.DashInputBuffer>();
      BuildSignalsArrayOnComponentRemoved<Quantum.DashInputBuffer>();
      BuildSignalsArrayOnComponentAdded<Quantum.LSDF_CameraInfo>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LSDF_CameraInfo>();
      BuildSignalsArrayOnComponentAdded<Quantum.LSDF_Ground>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LSDF_Ground>();
      BuildSignalsArrayOnComponentAdded<Quantum.LSDF_HitboxInfo>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LSDF_HitboxInfo>();
      BuildSignalsArrayOnComponentAdded<Quantum.LSDF_Player>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LSDF_Player>();
      BuildSignalsArrayOnComponentAdded<Quantum.LSDF_TestEnemy>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LSDF_TestEnemy>();
      BuildSignalsArrayOnComponentAdded<Quantum.LSDF_Wall>();
      BuildSignalsArrayOnComponentRemoved<Quantum.LSDF_Wall>();
      BuildSignalsArrayOnComponentAdded<MapEntityLink>();
      BuildSignalsArrayOnComponentRemoved<MapEntityLink>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceAgent>();
      BuildSignalsArrayOnComponentAdded<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentRemoved<NavMeshAvoidanceObstacle>();
      BuildSignalsArrayOnComponentAdded<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentRemoved<NavMeshPathfinder>();
      BuildSignalsArrayOnComponentAdded<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentRemoved<NavMeshSteeringAgent>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsBody3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsBody3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCallbacks3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsCollider3D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints2D>();
      BuildSignalsArrayOnComponentAdded<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentRemoved<PhysicsJoints3D>();
      BuildSignalsArrayOnComponentAdded<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentRemoved<Quantum.PlayerLink>();
      BuildSignalsArrayOnComponentAdded<Quantum.TickToDestroy>();
      BuildSignalsArrayOnComponentRemoved<Quantum.TickToDestroy>();
      BuildSignalsArrayOnComponentAdded<Transform2D>();
      BuildSignalsArrayOnComponentRemoved<Transform2D>();
      BuildSignalsArrayOnComponentAdded<Transform2DVertical>();
      BuildSignalsArrayOnComponentRemoved<Transform2DVertical>();
      BuildSignalsArrayOnComponentAdded<Transform3D>();
      BuildSignalsArrayOnComponentRemoved<Transform3D>();
      BuildSignalsArrayOnComponentAdded<View>();
      BuildSignalsArrayOnComponentRemoved<View>();
    }
    partial void SetPlayerInputCodeGen(PlayerRef player, Input input) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      var i = _globals->input.GetPointer(player);
      i->Left = i->Left.Update(this.Number, input.Left);
      i->Right = i->Right.Update(this.Number, input.Right);
      i->Up = i->Up.Update(this.Number, input.Up);
      i->Down = i->Down.Update(this.Number, input.Down);
      i->LeftPunch = i->LeftPunch.Update(this.Number, input.LeftPunch);
      i->RightPunch = i->RightPunch.Update(this.Number, input.RightPunch);
      i->LeftKick = i->LeftKick.Update(this.Number, input.LeftKick);
      i->RightKick = i->RightKick.Update(this.Number, input.RightKick);
    }
    public Input* GetPlayerInput(PlayerRef player) {
      if ((int)player >= (int)_globals->input.Length) { throw new System.ArgumentOutOfRangeException("player"); }
      return _globals->input.GetPointer(player);
    }
    partial void GetPlayerLastConnectionStateCodeGen(ref BitSetRef bitSet) {
      bitSet = new(_globals->PlayerLastConnectionState.Bits, _globals->PlayerLastConnectionState.Length);
    }
    partial void ResetPhysicsCodeGen() {
      if (Context.Physics2D != null && Physics2D.Map != null && Physics2D.Map.Guid.IsDynamic) Physics2D.ResetMap();
      Physics2D.Init(_globals->PhysicsState2D.MapStaticCollidersState.TrackedMap);
      if (Context.Physics3D != null && Physics3D.Map != null && Physics3D.Map.Guid.IsDynamic) Physics3D.ResetMap();
      Physics3D.Init(_globals->PhysicsState3D.MapStaticCollidersState.TrackedMap);
    }
    public unsafe partial struct FrameSignals {
      public void OnAnimatorStateEnter(EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, Addons.Animator.AnimatorState state) {
        var array = _f._ISignalOnAnimatorStateEnterSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorStateEnter(_f, entity, animator, graph, state);
          }
        }
      }
      public void OnAnimatorStateUpdate(EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, Addons.Animator.AnimatorState state, FP time, AnimatorStateType stateType) {
        var array = _f._ISignalOnAnimatorStateUpdateSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorStateUpdate(_f, entity, animator, graph, state, time, stateType);
          }
        }
      }
      public void OnAnimatorStateExit(EntityRef entity, AnimatorComponent* animator, AnimatorGraph graph, Addons.Animator.AnimatorState state) {
        var array = _f._ISignalOnAnimatorStateExitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnAnimatorStateExit(_f, entity, animator, graph, state);
          }
        }
      }
      public void OnTriggerNormalHit(TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox) {
        var array = _f._ISignalOnTriggerNormalHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerNormalHit(_f, info, player, animator, hitbox);
          }
        }
      }
      public void OnTriggerCounterHit(TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox) {
        var array = _f._ISignalOnTriggerCounterHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerCounterHit(_f, info, player, animator, hitbox);
          }
        }
      }
      public void OnTriggerGuard(TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox) {
        var array = _f._ISignalOnTriggerGuardSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerGuard(_f, info, player, animator, hitbox);
          }
        }
      }
      public void OnTriggerLauncherHit(TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox) {
        var array = _f._ISignalOnTriggerLauncherHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerLauncherHit(_f, info, player, animator, hitbox);
          }
        }
      }
      public void OnTriggerWallHit(TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox) {
        var array = _f._ISignalOnTriggerWallHitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerWallHit(_f, info, player, animator, hitbox);
          }
        }
      }
      public void OnTriggerEnemyGuard(TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox) {
        var array = _f._ISignalOnTriggerEnemyGuardSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerEnemyGuard(_f, info, player, animator, hitbox);
          }
        }
      }
      public void OnTriggerEnemyParring(TriggerInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_HitboxInfo* hitbox) {
        var array = _f._ISignalOnTriggerEnemyParringSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnTriggerEnemyParring(_f, info, player, animator, hitbox);
          }
        }
      }
      public void OnCollisionEnterWall(CollisionInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Wall* wall) {
        var array = _f._ISignalOnCollisionEnterWallSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionEnterWall(_f, info, player, animator, wall);
          }
        }
      }
      public void OnCollisionExitWall(ExitInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Wall* wall) {
        var array = _f._ISignalOnCollisionExitWallSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionExitWall(_f, info, player, animator, wall);
          }
        }
      }
      public void OnCollisionWallHitEnter(CollisionInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Wall* wall) {
        var array = _f._ISignalOnCollisionWallHitEnterSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionWallHitEnter(_f, info, player, animator, wall);
          }
        }
      }
      public void OnCollisionGroundEnter(CollisionInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Ground* ground) {
        var array = _f._ISignalOnCollisionGroundEnterSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionGroundEnter(_f, info, player, animator, ground);
          }
        }
      }
      public void OnCollisionGroundExit(ExitInfo2D info, LSDF_Player* player, AnimatorComponent* animator, LSDF_Ground* ground) {
        var array = _f._ISignalOnCollisionGroundExitSystems;
        for (Int32 i = 0; i < array.Length; ++i) {
          var s = array[i];
          if (_f.SystemIsEnabledInHierarchy((SystemBase)s)) {
            s.OnCollisionGroundExit(_f, info, player, animator, ground);
          }
        }
      }
    }
  }
  public unsafe partial class Statics {
    public static FrameSerializer.Delegate SerializeAnimatorRuntimeVariable;
    public static FrameSerializer.Delegate SerializeLayerData;
    public static FrameSerializer.Delegate SerializeFP;
    public static FrameSerializer.Delegate SerializeInt32;
    public static FrameSerializer.Delegate SerializeBlendTreeWeights;
    public static FrameSerializer.Delegate SerializeInput;
    static partial void InitStaticDelegatesGen() {
      SerializeAnimatorRuntimeVariable = Quantum.AnimatorRuntimeVariable.Serialize;
      SerializeLayerData = Quantum.LayerData.Serialize;
      SerializeFP = FP.Serialize;
      SerializeInt32 = (v, s) => {{ s.Stream.Serialize((Int32*)v); }};
      SerializeBlendTreeWeights = Quantum.BlendTreeWeights.Serialize;
      SerializeInput = Quantum.Input.Serialize;
    }
    static partial void RegisterSimulationTypesGen(TypeRegistry typeRegistry) {
      typeRegistry.Register(typeof(Quantum.AnimatorComponent), Quantum.AnimatorComponent.SIZE);
      typeRegistry.Register(typeof(Quantum.AnimatorRuntimeVariable), Quantum.AnimatorRuntimeVariable.SIZE);
      typeRegistry.Register(typeof(Quantum.AnimatorStateType), 1);
      typeRegistry.Register(typeof(AssetGuid), AssetGuid.SIZE);
      typeRegistry.Register(typeof(AssetRef), AssetRef.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet1024), Quantum.BitSet1024.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet128), Quantum.BitSet128.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet2048), Quantum.BitSet2048.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet256), Quantum.BitSet256.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet4096), Quantum.BitSet4096.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet512), Quantum.BitSet512.SIZE);
      typeRegistry.Register(typeof(Quantum.BitSet6), Quantum.BitSet6.SIZE);
      typeRegistry.Register(typeof(Quantum.BlendTreeWeights), Quantum.BlendTreeWeights.SIZE);
      typeRegistry.Register(typeof(Button), Button.SIZE);
      typeRegistry.Register(typeof(CallbackFlags), 4);
      typeRegistry.Register(typeof(CharacterController2D), CharacterController2D.SIZE);
      typeRegistry.Register(typeof(CharacterController3D), CharacterController3D.SIZE);
      typeRegistry.Register(typeof(ColorRGBA), ColorRGBA.SIZE);
      typeRegistry.Register(typeof(ComponentPrototypeRef), ComponentPrototypeRef.SIZE);
      typeRegistry.Register(typeof(ComponentTypeRef), ComponentTypeRef.SIZE);
      typeRegistry.Register(typeof(Quantum.CountAttackType), 4);
      typeRegistry.Register(typeof(Quantum.DashInputBuffer), Quantum.DashInputBuffer.SIZE);
      typeRegistry.Register(typeof(Quantum.DelayGuardType), 4);
      typeRegistry.Register(typeof(Quantum.DirectionType), 4);
      typeRegistry.Register(typeof(DistanceJoint), DistanceJoint.SIZE);
      typeRegistry.Register(typeof(DistanceJoint3D), DistanceJoint3D.SIZE);
      typeRegistry.Register(typeof(EntityPrototypeRef), EntityPrototypeRef.SIZE);
      typeRegistry.Register(typeof(EntityRef), EntityRef.SIZE);
      typeRegistry.Register(typeof(FP), FP.SIZE);
      typeRegistry.Register(typeof(FPBounds2), FPBounds2.SIZE);
      typeRegistry.Register(typeof(FPBounds3), FPBounds3.SIZE);
      typeRegistry.Register(typeof(FPMatrix2x2), FPMatrix2x2.SIZE);
      typeRegistry.Register(typeof(FPMatrix3x3), FPMatrix3x3.SIZE);
      typeRegistry.Register(typeof(FPMatrix4x4), FPMatrix4x4.SIZE);
      typeRegistry.Register(typeof(FPQuaternion), FPQuaternion.SIZE);
      typeRegistry.Register(typeof(FPVector2), FPVector2.SIZE);
      typeRegistry.Register(typeof(FPVector3), FPVector3.SIZE);
      typeRegistry.Register(typeof(FrameMetaData), FrameMetaData.SIZE);
      typeRegistry.Register(typeof(FrameTimer), FrameTimer.SIZE);
      typeRegistry.Register(typeof(HingeJoint), HingeJoint.SIZE);
      typeRegistry.Register(typeof(HingeJoint3D), HingeJoint3D.SIZE);
      typeRegistry.Register(typeof(Hit), Hit.SIZE);
      typeRegistry.Register(typeof(Hit3D), Hit3D.SIZE);
      typeRegistry.Register(typeof(Quantum.HitboxAttackType), 4);
      typeRegistry.Register(typeof(Quantum.HomingType), 4);
      typeRegistry.Register(typeof(Quantum.Input), Quantum.Input.SIZE);
      typeRegistry.Register(typeof(Quantum.InputButtons), 4);
      typeRegistry.Register(typeof(InputDirection), InputDirection.SIZE);
      typeRegistry.Register(typeof(InputDirectionMagnitude), InputDirectionMagnitude.SIZE);
      typeRegistry.Register(typeof(InputPitchYaw), InputPitchYaw.SIZE);
      typeRegistry.Register(typeof(IntVector2), IntVector2.SIZE);
      typeRegistry.Register(typeof(IntVector3), IntVector3.SIZE);
      typeRegistry.Register(typeof(Joint), Joint.SIZE);
      typeRegistry.Register(typeof(Joint3D), Joint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.LSDF_CameraInfo), Quantum.LSDF_CameraInfo.SIZE);
      typeRegistry.Register(typeof(Quantum.LSDF_Ground), Quantum.LSDF_Ground.SIZE);
      typeRegistry.Register(typeof(Quantum.LSDF_HitboxInfo), Quantum.LSDF_HitboxInfo.SIZE);
      typeRegistry.Register(typeof(Quantum.LSDF_Player), Quantum.LSDF_Player.SIZE);
      typeRegistry.Register(typeof(Quantum.LSDF_TestEnemy), Quantum.LSDF_TestEnemy.SIZE);
      typeRegistry.Register(typeof(Quantum.LSDF_Wall), Quantum.LSDF_Wall.SIZE);
      typeRegistry.Register(typeof(Quantum.LayerData), Quantum.LayerData.SIZE);
      typeRegistry.Register(typeof(LayerMask), LayerMask.SIZE);
      typeRegistry.Register(typeof(MapEntityId), MapEntityId.SIZE);
      typeRegistry.Register(typeof(MapEntityLink), MapEntityLink.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceAgent), NavMeshAvoidanceAgent.SIZE);
      typeRegistry.Register(typeof(NavMeshAvoidanceObstacle), NavMeshAvoidanceObstacle.SIZE);
      typeRegistry.Register(typeof(NavMeshPathfinder), NavMeshPathfinder.SIZE);
      typeRegistry.Register(typeof(NavMeshRegionMask), NavMeshRegionMask.SIZE);
      typeRegistry.Register(typeof(NavMeshSteeringAgent), NavMeshSteeringAgent.SIZE);
      typeRegistry.Register(typeof(NullableFP), NullableFP.SIZE);
      typeRegistry.Register(typeof(NullableFPVector2), NullableFPVector2.SIZE);
      typeRegistry.Register(typeof(NullableFPVector3), NullableFPVector3.SIZE);
      typeRegistry.Register(typeof(NullableNonNegativeFP), NullableNonNegativeFP.SIZE);
      typeRegistry.Register(typeof(PhysicsBody2D), PhysicsBody2D.SIZE);
      typeRegistry.Register(typeof(PhysicsBody3D), PhysicsBody3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks2D), PhysicsCallbacks2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCallbacks3D), PhysicsCallbacks3D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider2D), PhysicsCollider2D.SIZE);
      typeRegistry.Register(typeof(PhysicsCollider3D), PhysicsCollider3D.SIZE);
      typeRegistry.Register(typeof(PhysicsEngineState), PhysicsEngineState.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints2D), PhysicsJoints2D.SIZE);
      typeRegistry.Register(typeof(PhysicsJoints3D), PhysicsJoints3D.SIZE);
      typeRegistry.Register(typeof(PhysicsQueryRef), PhysicsQueryRef.SIZE);
      typeRegistry.Register(typeof(PhysicsSceneSettings), PhysicsSceneSettings.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerLink), Quantum.PlayerLink.SIZE);
      typeRegistry.Register(typeof(Quantum.PlayerMoveState), 1);
      typeRegistry.Register(typeof(PlayerRef), PlayerRef.SIZE);
      typeRegistry.Register(typeof(Ptr), Ptr.SIZE);
      typeRegistry.Register(typeof(QBoolean), QBoolean.SIZE);
      typeRegistry.Register(typeof(Quantum.Ptr), Quantum.Ptr.SIZE);
      typeRegistry.Register(typeof(QueryOptions), 2);
      typeRegistry.Register(typeof(RNGSession), RNGSession.SIZE);
      typeRegistry.Register(typeof(Shape2D), Shape2D.SIZE);
      typeRegistry.Register(typeof(Shape3D), Shape3D.SIZE);
      typeRegistry.Register(typeof(SpringJoint), SpringJoint.SIZE);
      typeRegistry.Register(typeof(SpringJoint3D), SpringJoint3D.SIZE);
      typeRegistry.Register(typeof(Quantum.TickToDestroy), Quantum.TickToDestroy.SIZE);
      typeRegistry.Register(typeof(Transform2D), Transform2D.SIZE);
      typeRegistry.Register(typeof(Transform2DVertical), Transform2DVertical.SIZE);
      typeRegistry.Register(typeof(Transform3D), Transform3D.SIZE);
      typeRegistry.Register(typeof(View), View.SIZE);
      typeRegistry.Register(typeof(Quantum._globals_), Quantum._globals_.SIZE);
    }
    static partial void InitComponentTypeIdGen() {
      ComponentTypeId.Reset(ComponentTypeId.BuiltInComponentCount + 10)
        .AddBuiltInComponents()
        .Add<Quantum.AnimatorComponent>(Quantum.AnimatorComponent.Serialize, null, Quantum.AnimatorComponent.OnRemoved, ComponentFlags.None)
        .Add<Quantum.DashInputBuffer>(Quantum.DashInputBuffer.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LSDF_CameraInfo>(Quantum.LSDF_CameraInfo.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LSDF_Ground>(Quantum.LSDF_Ground.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LSDF_HitboxInfo>(Quantum.LSDF_HitboxInfo.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LSDF_Player>(Quantum.LSDF_Player.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LSDF_TestEnemy>(Quantum.LSDF_TestEnemy.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.LSDF_Wall>(Quantum.LSDF_Wall.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.PlayerLink>(Quantum.PlayerLink.Serialize, null, null, ComponentFlags.None)
        .Add<Quantum.TickToDestroy>(Quantum.TickToDestroy.Serialize, null, null, ComponentFlags.None)
        .Finish();
    }
    [Preserve()]
    public static void EnsureNotStrippedGen() {
      FramePrinter.EnsureNotStripped();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.AnimatorStateType>();
      FramePrinter.EnsurePrimitiveNotStripped<CallbackFlags>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.CountAttackType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.DelayGuardType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.DirectionType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.HitboxAttackType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.HomingType>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.InputButtons>();
      FramePrinter.EnsurePrimitiveNotStripped<Quantum.PlayerMoveState>();
      FramePrinter.EnsurePrimitiveNotStripped<QueryOptions>();
    }
  }
}
#pragma warning restore 0109
#pragma warning restore 1591
